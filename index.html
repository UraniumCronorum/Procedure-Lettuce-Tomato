<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>LambdaVania by oplS16projects</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/oplS16projects/Procedure-Lettuce-Tomato">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/oplS16projects/Procedure-Lettuce-Tomato/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/oplS16projects/Procedure-Lettuce-Tomato/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>LambdaVania</h1>
          <p>FP for Wesley Nuzzo and David Benoit</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/oplS16projects">oplS16projects</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a id="fp7-webpage-lambdavania" class="anchor" href="#fp7-webpage-lambdavania" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FP7-webpage LambdaVania</h1>

<h2>
<a id="authors" class="anchor" href="#authors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors</h2>

<p>Wesley Nuzzo</p>

<p>David Benoit</p>

<h2>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h2>

<p>LambdaVania is a 2D sidescroller game, in the vein of the Metroidvania/Igavania style of games. The music for the game, and to some extent the level design, is procedurally generated (level layout is currently one-dimensional).</p>

<h2>
<a id="screenshot" class="anchor" href="#screenshot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Screenshot</h2>

<p><img src="screenshot1.png" alt="Gameplay Screenshot"></p>

<h2>
<a id="concepts-demonstrated" class="anchor" href="#concepts-demonstrated" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Concepts Demonstrated</h2>

<ul>
<li>
<strong>Higher order procedures</strong> such as map and foldl/foldr to convert lists of notes into rsounds, and consolidate multiple rsounds into a single rsound.

<ul>
<li>Map and foldl/foldr are also used to implement level graphics via a tiling system.</li>
</ul>
</li>
<li>
<strong>Abstraction</strong> of sounds as musical notes.

<ul>
<li>There is an <strong>abstraction barrier</strong> between the graphics library and the actual game code, so that the means by which the graphics are loaded/produced doesn't necessarily break the game code.</li>
</ul>
</li>
</ul>



<h2>
<a id="external-technology-and-libraries" class="anchor" href="#external-technology-and-libraries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>External Technology and Libraries</h2>

<p>Libraries used:</p>

<ul>
<li>rsound (<a href="https://docs.racket-lang.org/rsound/index.html">https://docs.racket-lang.org/rsound/index.html</a>)

<ul>
<li>Used for actually representing and playing the sounds generated by the music generator.</li>
</ul>
</li>
<li>2htdp (<a href="https://docs.racket-lang.org/teachpack/2htdpimage.html">https://docs.racket-lang.org/teachpack/2htdpimage.html</a> and <a href="https://docs.racket-lang.org/teachpack/2htdpuniverse.html">https://docs.racket-lang.org/teachpack/2htdpuniverse.html</a>)

<ul>
<li>Used to implement animation and interaction, i.e. the video game itself.</li>
</ul>
</li>
<li>racket/gui (<a href="https://docs.racket-lang.org/gui/">https://docs.racket-lang.org/gui/</a>)

<ul>
<li>Used in a variety of different ways as part of the process by which the sprites and level tiles were created.</li>
<li>In particular, the draw library (<a href="https://docs.racket-lang.org/draw/index.html">https://docs.racket-lang.org/draw/index.html</a>) allows, well, drawing.</li>
</ul>
</li>
</ul>

<p>External technology:</p>

<ul>
<li>GIMP (<a href="https://www.gimp.org/">https://www.gimp.org/</a>) to make minor edits to certain completed graphics.</li>
</ul>



<h2>
<a id="favorite-scheme-expressions" class="anchor" href="#favorite-scheme-expressions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Favorite Scheme Expressions</h2>

<h4>
<a id="wesley" class="anchor" href="#wesley" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Wesley</h4>

<p>The following function is used to create the level background by tiling a single image. What's cool about this to me is that it uses the accumulate syntax to create the graphics in a similar way to the fashion that we normally use it to construct lists. It's an interesting demonstration of exactly the kind of power that Racket's higher order procedures actually have.</p>

<pre><code>(define (tile image x y)
  ;; Generate the rows
  (let ([row (foldl (lambda (i out) (overlay/xy out i 0 image))
                    empty-image
                    (map (lambda (i) (* i (image-width image))) (range x)))])
    ;; Generate the entire image based on the rows
    (foldl (lambda (i out) (overlay/xy out 0 i row))
           empty-image
           (map (lambda (i) (* i (image-height image)))
                (range y)))))
</code></pre>

<h4>
<a id="david" class="anchor" href="#david" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>David</h4>

<p>While generating the psuedo-random audio sequences, the program uses symbolic music theory objects rather than rsounds during the computation process.  This is both for performance and programming efficiency.  The base unit is a music note. Notes are organized into measures, which are organized into staff parts, which are organized on an ensemble staff.  The resulting ensemble staff is an object containing lists of lists of lists of note objects.</p>

<p>My favorite section of code in this project is this series of abstractions of map and foldl expressions, which builds an ensemble staff into a single playable rsound.  </p>

<pre><code>;; Convert an ensemble-staff object into an rsound
(define (e-staff-&gt;rsound staff)
  (rs-overlay* (map staff-part-&gt;rsound (e-staff-&gt;partlist staff))))

;; Convert a staff-part into an rsound
(define (staff-part-&gt;rsound staff-part)
 (if (staff-part? staff-part)
     (measure-&gt;rsound
      (append-measure*
       (staff-part-&gt;measurelist staff-part))
      (instrument-&gt;proc (staff-part-&gt;instrument staff-part)))
     (raise-type-error 'staff-part-&gt;instrument "StaffPart" staff-part)))

;; Take a measure and a procedure that converts notes to rsounds
;; and apply the procedure to all notes in the measure
(define (measure-&gt;rsound measure note-to-rsound-proc)
  (cond ((and (measure? measure) (procedure? note-to-rsound-proc))
           (rs-append* (map (lambda (x) 
                              (if (harmony? x)
                                (harmony-&gt;rsound x  note-to-rsound-proc)
                                (note-&gt;rsound x note-to-rsound-proc)))
                            (measure-&gt;notelist measure))))
         (else
          (if (procedure? note-to-rsound-proc)
             (raise-type-error 'arg1 "Measure" measure)
             (raise-type-error 'arg2 "procedure" note-to-rsound-proc)))))

;; Take a note object and a procedure which can turn
;; the note into an rsound.  Call the procedure with
;; the note object as an argument
(define (note-&gt;rsound note note-to-rsound-proc)
  (cond ((and (note? note) (procedure? note-to-rsound-proc))
           (rs-filter (note-to-rsound-proc note) reverb))
         (else
          (if (procedure? note-to-rsound-proc)
             (raise-type-error 'arg1 "Note" note)
             ((raise-type-error 'arg2 "procedure" note-to-rsound-proc))))))


</code></pre>

<p>All of the previous append-{item} and append-{item}* functions are implemented by combining append with foldl in the same manner as the following example:</p>

<pre><code>;; Concatenate two measure objects
(define (append-measure m1 m2)
  (cond ((and (measure? m1) (measure? m2))
         (make-measure (append (measure-&gt;notelist m1)
                              (measure-&gt;notelist m2))))
         (else
           (if (measure? m1)
             (raise-type-error 'arg1 "Measure" m1)
             (raise-type-error 'arg2 "Measure" m1)))))

;; Concatenate a list of measure objects
(define (append-measure* measurelist)
  (foldl (lambda (x y)
           (if (eq? y '())
               x
                (append-measure x y))) '() measurelist))
</code></pre>



<h2>
<a id="additional-remarks" class="anchor" href="#additional-remarks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Additional Remarks</h2>



<p>Procedural Generation Specifics:</p>

<ul>
<li>Audio

<ul>
<li>Harmonic progressions are chosen psuedo-randomly from a list of pre-defined progressions</li>
<li>Notes are chosen psuedo-randomly given the current harmony, key, and the instrument's range</li>
<li>Rhythyms are determined by randomly and recursively subdividing measures by powers of two, up to a recursion depth of 5. </li>
<li>The key is chosen at random.</li>
<li>The tempo is chosen at random between a maximum and minimum value.</li>
<li>Synth instruments are chosen at random from the rsound/single-cycle library
Notes:</li>
</ul>
</li>
<li>The list of harmonic progressions is currently small, and all progressions are in minor keys.  This is to assure all generated audio fits the atmosphere of the game.  It is, however, very easy to add new progressions to the generator.<br>
</li>
</ul>

<p>Issues:</p>

<p>Both the 2htdp/image and rsound libraries seem to run very slowly in some circumstances. As a result, this game takes a long time (couple minutes) to load.</p>

<p>Due to lag in the rsound backend, we were not able to build and queue audio clips back to back reliably at runtime.  There would either be signifacant sound overlap or large gaps between the sound clips.  As such, we decided to build one large audio segment at the beginning and play just that.  Because of this, the audio will stop playing when the clip is over.</p>

<p>Sometimes the rsound/portaudio backend gets messed up and just plays static.  This is more common when other sound-producing applications are running on the host operating system.  To fix:</p>

<ul>
<li>Stop the game</li>
<li>Close all other sound-producing applications</li>
<li>If you are using drracket, it must be restarted after other applications have been closed.</li>
</ul>

<h1>
<a id="how-to-download-and-run" class="anchor" href="#how-to-download-and-run" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How to Download and Run</h1>

<p>Gameplay/Sprite Frame Animation Demo</p>

<ul>
<li>cd to project root dir and exec "racket run-game.racket"</li>
</ul>




      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
